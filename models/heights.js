/** heights model */

/** import our common modules */
const COLLECTIONS = require("../common/collections");
const dmm = require("../common/decimillimeter");
const mongo = require("../common/mongo.js");
const validator = require("validator");

/**
 * creates a new entry object for the database with the following parameters
 * 
 * rank is not recorded since rank can be calculated from the database
 * height in cm/ft are  not recorded since they are be calculated from the database as well
 * 
 * height is recorded in (dmm) decimilli-meters 10^-4
 * 
 * @param {String} p_name - name of country if entry is a country, or name of custom entry
 * @param {Number} p_male - height of male (dmm)
 * @param {Number} p_female - height of female (dmm)
 * @param {Boolean} p_is_country - optional boolean value specifying whether this entry is a country from the dataset or a custom value from the us
 * @returns {Object} - height object generated by the parameters
 */
function createHeightObject(p_name, p_male, p_female, p_is_country){
    /** validate the optional `is_country` parameter since missing parameters in javascript default to undefined and `is_country` is a boolean */
    p_is_country = (p_is_country === undefined)? false : p_is_country;

    /** error checking */
    if(validator.isEmpty(p_name)) throw new Error("p_name cannot be an empty string");
    if(typeof p_male !== "number") throw new Error("p_male must be number");
    if(typeof p_female !== "number") throw new Error("p_female must be number");
    if(p_male < 0) throw new Error("p_male cannot be a negative number");
    if(p_female < 0) throw new Error("p_female cannot be a negative number");

    let output = {
        name : p_name,
        male : p_male,
        female : p_female,
        is_country : p_is_country
    };
    return output;
}

/**
 * creates a new record in the collection with the following record object
 * @param {Object} p_record - record object obtained from createHeightObject
 * @returns {Object} - result object from mongodb.insertOne()
 */
async function createRecord(p_record){
    try {
        let collection = await mongo.getCollection(COLLECTIONS.HEIGHTS);
        /** only create the record if the record doesn't exist already since updateRecord can be used to edit existing records and we want to avoid duplicate entries */
        let result_array = await collection.find({"name" : p_record.name}).toArray();
        if(result_array.length > 0){
            throw "record exists already";
        }
        return await collection.insertOne(p_record);
    }
    catch(error){
        throw error;
    }
}

/**
 * retreive records matching the name from the database
 * @param {String} p_name - name of the records to retreive
 * @returns {Array(Object)} the array of records matching the name specified, empty array otherwise
 */
async function readRecord(p_name){
    try{
        let collection = await mongo.getCollection(COLLECTIONS.HEIGHTS);
        return await collection.find({"name" : p_name}).toArray();
    }
    catch(error){
        throw error;
    }
}

/**
 * extended function to retreive records allowing advance querying, sorting and limiting
 * @param {Object} p_query - object specifying the search query in the database; defaults to {}
 * @param {Object} p_sort - object specifying the sorting order of the query in the database; default sort order is name-by-descending order
 * @param {Number} p_limit - number specifying the limit of the search query; default limit is 0 (unlimited)
 * @returns {Array(Object)} array containing the result of the `.find().sort().limit()` function chain
 */
async function readRecordEx(p_query, p_sort, p_limit){
    /** set default values for parameters */
    p_query = (p_query === undefined)? {} : p_query;
    p_sort = (p_sort === undefined)? {"name" : 1} : p_sort;
    p_limit = (p_limit === undefined)? 0 : p_limit;
    try{
        let collection = await mongo.getCollection(COLLECTIONS.HEIGHTS);
        return await collection.find(p_query).sort(p_sort).limit(p_limit).toArray();
    }
    catch(error){
        throw error;
    }
}

/**
 * updates a record by name with a new record of updated values
 * @param {String} p_name - string containing the name of the record to update
 * @param {Object} p_new_record - new record containing updated values to replace the old record with
 * @returns {Object} the result object obtained from mongodb.updateOne()
 */
async function updateRecord(p_name, p_new_record){
    try{
        let collection = await mongo.getCollection(COLLECTIONS.HEIGHTS);

        /** error checking to prevent duplicates being created from `.updateRecord()` */
        let search_results = await collection.find({name : p_new_record.name}).toArray();
        if(search_results.length > 0){
            throw "new_name is an existing record";
        }

        /** error checking to see if the record actually exists */
        search_results = await collection.find({name : p_name}).toArray();
        if(search_results.length < 1){
            throw "record does not exist";
        }

        /** use the old value if the new values are undefined */
        p_new_record.name = (p_new_record.name === undefined)? search_results[0].name : p_new_record.name;
        p_new_record.male = (p_new_record.male === undefined)? search_results[0].male : p_new_record.male;
        p_new_record.female = (p_new_record.female === undefined)? search_results[0].female : p_new_record.female;

        return await collection.updateOne({"name" : p_name}, {$set : p_new_record});
    }
    catch(error){
        throw error;
    }
}

/**
 * deletes the first record matching the specified name from the collection
 * @param {String} p_name - name of the record to delete
 * @returns {Object} - the result object from the mongodb.deleteOne() function
 */
async function deleteRecord(p_name){
    try{
        let collection = await mongo.getCollection(COLLECTIONS.HEIGHTS);
        return await collection.deleteOne({"name" : p_name});
    }
    catch(error){
        throw error;
    }
}

/**
 * resets the collection by clearing all entries from the collection and populating it with data from the dataset.csv
 * @returns {Object} - result object from the `.insertMany()` function
 */
async function resetDatabase(){
    try{
        /**
         * import the fs/promises module for file system operations and integration with async/await
         * load the dataset
         */
        const fs = require("fs/promises");
        const dataset = await fs.readFile("./common/dataset.csv", {encoding:"utf8", flag : "r"});

        /**
         * split the dataset text file into lines
         * and loop through each line ignoring the header
         */
        let height_records = [];
        const dataset_lines = dataset.split("\n");
        for(i = 1; i < dataset_lines.length - 1; i++){
            /**
             * split the current line into their comma-separated-values
             * parse the float from the csv column
             *  convert the result to decimillimeters from centimeters
             *  parse result as integer to keep integer math accuracy
             *      centimeter values from the dataset.csv have a fixed precision of 2 and can convert cleanly to decimillimeters
             * create a new height object record with the specified data
             * append the new record into the array of height records
             */
            let dataset_line_csvs = dataset_lines[i].split(",");
            let male_dmm = parseInt(dmm.fromCentimeters(parseFloat(dataset_line_csvs[2])));
            let female_dmm = parseInt(dmm.fromCentimeters(parseFloat(dataset_line_csvs[3])));
            let new_height_record = createHeightObject(dataset_line_csvs[1], male_dmm, female_dmm, true);
            height_records.push(new_height_record);
        }

        /**
         * get the handler for the collection specified with COLLECTIONS.HEIGHTS
         * delete all previous entries if any to clear the database and avoid duplicate entries
         * then insert the array of height_records into the collection returning the result object
         */
        let collection = await mongo.getCollection(COLLECTIONS.HEIGHTS);
        await collection.deleteMany({});
        return await collection.insertMany(height_records);
    }
    catch(error){
        throw error;
    }
}

module.exports = {createHeightObject, createRecord, readRecord, readRecordEx, updateRecord, deleteRecord, resetDatabase};